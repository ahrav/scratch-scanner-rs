//! Integration tests for in-memory commit-graph and MIDX artifacts.
//!
//! These tests verify that in-memory artifacts produce identical results to
//! disk-based artifacts generated by `git maintenance`.

use std::collections::HashSet;
use std::fs;
use std::path::Path;
use std::process::Command;

use scanner_rs::git_scan::{
    build_midx_bytes, collect_pack_dirs, load_commits_from_tips, resolve_pack_paths_from_midx,
    CommitGraph, CommitGraphMem, CommitGraphView, CommitLoadLimits, CommitPlanIter,
    CommitWalkLimits, GitRepoPaths, MidxBuildLimits, MidxView, ObjectFormat, OidBytes,
    ParentScratch, RefWatermarkStore, RepoOpenError, RepoOpenLimits, StartSetConfig,
    StartSetResolver,
};
use tempfile::TempDir;

// ============================================================================
// Test helpers
// ============================================================================

fn git_available() -> bool {
    Command::new("git").arg("--version").output().is_ok()
}

fn run_git(repo: &Path, args: &[&str]) {
    let status = Command::new("git")
        .args(args)
        .current_dir(repo)
        .status()
        .expect("failed to run git");
    assert!(status.success(), "git command failed: {args:?}");
}

fn git_output(repo: &Path, args: &[&str]) -> String {
    let out = Command::new("git")
        .args(args)
        .current_dir(repo)
        .output()
        .expect("failed to run git");
    assert!(out.status.success(), "git command failed: {args:?}");
    String::from_utf8(out.stdout).expect("git output not utf8")
}

fn decode_hex(hex: &str) -> Vec<u8> {
    let mut out = Vec::with_capacity(hex.len() / 2);
    let bytes = hex.as_bytes();
    let mut i = 0;
    while i < bytes.len() {
        let hi = (bytes[i] as char).to_digit(16).unwrap();
        let lo = (bytes[i + 1] as char).to_digit(16).unwrap();
        out.push(((hi << 4) | lo) as u8);
        i += 2;
    }
    out
}

fn oid_from_hex(hex: &str) -> OidBytes {
    let bytes = decode_hex(hex.trim());
    OidBytes::from_slice(&bytes)
}

/// Get all commit OIDs reachable from HEAD using `git rev-list`.
fn rev_list_all(repo: &Path) -> Vec<OidBytes> {
    let out = git_output(repo, &["rev-list", "--all"]);
    out.lines().map(oid_from_hex).collect()
}

/// Get the tree OID for a commit using `git rev-parse`.
fn tree_oid_for_commit(repo: &Path, commit_hex: &str) -> OidBytes {
    let out = git_output(repo, &["rev-parse", &format!("{commit_hex}^{{tree}}")]);
    oid_from_hex(&out)
}

/// Get parent commit OIDs for a commit.
fn parent_oids(repo: &Path, commit_hex: &str) -> Vec<OidBytes> {
    let out = git_output(repo, &["rev-parse", &format!("{commit_hex}^@")]);
    if out.trim().is_empty() {
        vec![]
    } else {
        out.lines().map(oid_from_hex).collect()
    }
}

/// Creates a test repository with a linear history of commits containing blobs.
fn create_repo_with_linear_history(num_commits: usize) -> TempDir {
    let tmp = TempDir::new().unwrap();
    run_git(tmp.path(), &["init", "-b", "main"]);
    run_git(tmp.path(), &["config", "user.email", "test@example.com"]);
    run_git(tmp.path(), &["config", "user.name", "Test User"]);

    for i in 0..num_commits {
        let filename = format!("file{i}.txt");
        let content = format!("content for commit {i}\nsecret_{i}_data\n");
        fs::write(tmp.path().join(&filename), content).unwrap();
        run_git(tmp.path(), &["add", &filename]);
        run_git(tmp.path(), &["commit", "-m", &format!("commit {i}")]);
    }

    // Create pack file from loose objects
    run_git(tmp.path(), &["gc", "--aggressive"]);

    // Write commit-graph for comparison
    run_git(tmp.path(), &["commit-graph", "write", "--reachable"]);

    // Write MIDX for comparison
    run_git(tmp.path(), &["multi-pack-index", "write"]);

    tmp
}

/// Creates a test repository with branches and a merge commit.
fn create_repo_with_merge() -> TempDir {
    let tmp = TempDir::new().unwrap();
    run_git(tmp.path(), &["init", "-b", "main"]);
    run_git(tmp.path(), &["config", "user.email", "test@example.com"]);
    run_git(tmp.path(), &["config", "user.name", "Test User"]);

    // Initial commit
    fs::write(tmp.path().join("base.txt"), "base content\n").unwrap();
    run_git(tmp.path(), &["add", "base.txt"]);
    run_git(tmp.path(), &["commit", "-m", "initial"]);

    // Create branch and add commit
    run_git(tmp.path(), &["checkout", "-b", "feature"]);
    fs::write(tmp.path().join("feature.txt"), "feature content\n").unwrap();
    run_git(tmp.path(), &["add", "feature.txt"]);
    run_git(tmp.path(), &["commit", "-m", "feature commit"]);

    // Back to main and add commit
    run_git(tmp.path(), &["checkout", "main"]);
    fs::write(tmp.path().join("main.txt"), "main content\n").unwrap();
    run_git(tmp.path(), &["add", "main.txt"]);
    run_git(tmp.path(), &["commit", "-m", "main commit"]);

    // Merge feature into main (creates merge commit with 2 parents)
    run_git(tmp.path(), &["merge", "feature", "-m", "merge feature"]);

    // Pack and write artifacts
    run_git(tmp.path(), &["gc", "--aggressive"]);
    run_git(tmp.path(), &["commit-graph", "write", "--reachable"]);
    run_git(tmp.path(), &["multi-pack-index", "write"]);

    tmp
}

// ============================================================================
// MIDX Parity Tests
// ============================================================================

#[test]
fn midx_build_matches_git_object_count() {
    if !git_available() {
        eprintln!("git not available; skipping");
        return;
    }

    let tmp = create_repo_with_linear_history(5);
    let git_dir = tmp.path().join(".git");
    let objects_dir = git_dir.join("objects");
    let pack_dir = objects_dir.join("pack");

    // Read git-generated MIDX
    let git_midx_path = pack_dir.join("multi-pack-index");
    let git_midx_bytes = fs::read(&git_midx_path).expect("git MIDX should exist");
    let git_midx = MidxView::parse(&git_midx_bytes, ObjectFormat::Sha1).unwrap();

    // Build our MIDX
    let paths =
        GitRepoPaths::resolve::<RepoOpenError, _>(tmp.path(), &RepoOpenLimits::DEFAULT).unwrap();
    let our_midx_bytes = build_midx_bytes(&paths, ObjectFormat::Sha1, &MidxBuildLimits::default())
        .expect("MIDX build should succeed");
    let our_midx = MidxView::parse(our_midx_bytes.as_slice(), ObjectFormat::Sha1).unwrap();

    // Verify object counts match
    assert_eq!(
        our_midx.object_count(),
        git_midx.object_count(),
        "in-memory MIDX object count should match git MIDX"
    );
}

#[test]
fn midx_build_all_oids_findable() {
    if !git_available() {
        eprintln!("git not available; skipping");
        return;
    }

    let tmp = create_repo_with_linear_history(3);
    let git_dir = tmp.path().join(".git");
    let objects_dir = git_dir.join("objects");
    let pack_dir = objects_dir.join("pack");

    // Get all objects from git
    let all_objects_output = git_output(tmp.path(), &["rev-list", "--all", "--objects"]);
    let all_oids: Vec<OidBytes> = all_objects_output
        .lines()
        .filter_map(|line| {
            let hex = line.split_whitespace().next()?;
            if hex.len() >= 40 {
                Some(oid_from_hex(hex))
            } else {
                None
            }
        })
        .collect();

    assert!(!all_oids.is_empty(), "should have some objects");

    // Build our MIDX
    let paths =
        GitRepoPaths::resolve::<RepoOpenError, _>(tmp.path(), &RepoOpenLimits::DEFAULT).unwrap();
    let our_midx_bytes =
        build_midx_bytes(&paths, ObjectFormat::Sha1, &MidxBuildLimits::default()).unwrap();
    let our_midx = MidxView::parse(our_midx_bytes.as_slice(), ObjectFormat::Sha1).unwrap();

    // Also read git MIDX for comparison
    let git_midx_path = pack_dir.join("multi-pack-index");
    let git_midx_bytes = fs::read(&git_midx_path).expect("git MIDX should exist");
    let git_midx = MidxView::parse(&git_midx_bytes, ObjectFormat::Sha1).unwrap();

    // Verify every OID is findable in both MIDXes
    for oid in &all_oids {
        let our_result = our_midx.find_oid(oid);
        let git_result = git_midx.find_oid(oid);

        assert!(
            our_result.is_ok(),
            "our MIDX lookup should not error for {oid}"
        );
        assert!(
            git_result.is_ok(),
            "git MIDX lookup should not error for {oid}"
        );

        let our_idx = our_result.unwrap();
        let git_idx = git_result.unwrap();

        assert!(our_idx.is_some(), "our MIDX should find OID {oid}");
        assert!(git_idx.is_some(), "git MIDX should find OID {oid}");
    }
}

// ============================================================================
// CommitGraphMem Parity Tests
// ============================================================================

#[test]
fn commit_graph_mem_matches_view_commit_count() {
    if !git_available() {
        eprintln!("git not available; skipping");
        return;
    }

    let tmp = create_repo_with_linear_history(5);

    // Open disk-based commit graph
    let paths =
        GitRepoPaths::resolve::<RepoOpenError, _>(tmp.path(), &RepoOpenLimits::DEFAULT).unwrap();
    let info_dir = paths.objects_dir.join("info");
    let disk_cg = CommitGraphView::open(&info_dir, ObjectFormat::Sha1).unwrap();

    // Build in-memory commit graph
    let pack_dir = paths.objects_dir.join("pack");
    let git_midx_path = pack_dir.join("multi-pack-index");
    let git_midx_bytes = fs::read(&git_midx_path).unwrap();
    let midx = MidxView::parse(&git_midx_bytes, ObjectFormat::Sha1).unwrap();

    let tips = rev_list_all(tmp.path());
    let tip_oid = tips.first().unwrap();

    let pack_dirs = collect_pack_dirs(&paths);
    let pack_paths = resolve_pack_paths_from_midx(&midx, &pack_dirs).unwrap();

    let commits = load_commits_from_tips(
        &[*tip_oid],
        &midx,
        &pack_paths,
        ObjectFormat::Sha1,
        &CommitLoadLimits::default(),
        None,
    )
    .unwrap();

    let mem_cg = CommitGraphMem::build(commits, ObjectFormat::Sha1).unwrap();

    // Verify commit counts match
    assert_eq!(
        mem_cg.num_commits(),
        disk_cg.num_commits(),
        "in-memory commit graph should have same commit count as disk"
    );
}

#[test]
fn commit_graph_mem_all_commits_lookupable() {
    if !git_available() {
        eprintln!("git not available; skipping");
        return;
    }

    let tmp = create_repo_with_linear_history(4);

    // Get all commit OIDs from git
    let all_commits = rev_list_all(tmp.path());
    assert!(!all_commits.is_empty(), "should have commits");

    // Build in-memory commit graph
    let paths =
        GitRepoPaths::resolve::<RepoOpenError, _>(tmp.path(), &RepoOpenLimits::DEFAULT).unwrap();
    let pack_dir = paths.objects_dir.join("pack");
    let git_midx_path = pack_dir.join("multi-pack-index");
    let git_midx_bytes = fs::read(&git_midx_path).unwrap();
    let midx = MidxView::parse(&git_midx_bytes, ObjectFormat::Sha1).unwrap();

    let pack_dirs = collect_pack_dirs(&paths);
    let pack_paths = resolve_pack_paths_from_midx(&midx, &pack_dirs).unwrap();

    let tip_oid = all_commits.first().unwrap();
    let commits = load_commits_from_tips(
        &[*tip_oid],
        &midx,
        &pack_paths,
        ObjectFormat::Sha1,
        &CommitLoadLimits::default(),
        None,
    )
    .unwrap();

    let mem_cg = CommitGraphMem::build(commits, ObjectFormat::Sha1).unwrap();

    // Verify every commit is lookupable
    for commit_oid in &all_commits {
        let pos = mem_cg.lookup(commit_oid).unwrap();
        assert!(
            pos.is_some(),
            "commit {commit_oid} should be in in-memory graph"
        );
    }
}

#[test]
fn commit_graph_mem_generation_numbers_valid() {
    if !git_available() {
        eprintln!("git not available; skipping");
        return;
    }

    let tmp = create_repo_with_linear_history(5);

    let paths =
        GitRepoPaths::resolve::<RepoOpenError, _>(tmp.path(), &RepoOpenLimits::DEFAULT).unwrap();
    let pack_dir = paths.objects_dir.join("pack");
    let git_midx_path = pack_dir.join("multi-pack-index");
    let git_midx_bytes = fs::read(&git_midx_path).unwrap();
    let midx = MidxView::parse(&git_midx_bytes, ObjectFormat::Sha1).unwrap();

    let all_commits = rev_list_all(tmp.path());
    let tip_oid = all_commits.first().unwrap();

    let pack_dirs = collect_pack_dirs(&paths);
    let pack_paths = resolve_pack_paths_from_midx(&midx, &pack_dirs).unwrap();

    let commits = load_commits_from_tips(
        &[*tip_oid],
        &midx,
        &pack_paths,
        ObjectFormat::Sha1,
        &CommitLoadLimits::default(),
        None,
    )
    .unwrap();

    let mem_cg = CommitGraphMem::build(commits, ObjectFormat::Sha1).unwrap();

    // Verify generation numbers:
    // - All generations >= 1
    // - Child generation > parent generation
    let mut scratch = ParentScratch::new();

    for commit_oid in &all_commits {
        let pos = mem_cg.lookup(commit_oid).unwrap().unwrap();
        let gen = mem_cg.generation(pos);

        assert!(gen >= 1, "generation should be >= 1");

        mem_cg.collect_parents(pos, 256, &mut scratch).unwrap();
        for parent_pos in scratch.as_slice() {
            let parent_gen = mem_cg.generation(*parent_pos);
            assert!(
                gen > parent_gen,
                "child generation ({gen}) should be > parent generation ({parent_gen})"
            );
        }
    }
}

#[test]
fn commit_graph_mem_parent_relationships_match_git() {
    if !git_available() {
        eprintln!("git not available; skipping");
        return;
    }

    let tmp = create_repo_with_merge();

    let paths =
        GitRepoPaths::resolve::<RepoOpenError, _>(tmp.path(), &RepoOpenLimits::DEFAULT).unwrap();
    let pack_dir = paths.objects_dir.join("pack");
    let git_midx_path = pack_dir.join("multi-pack-index");
    let git_midx_bytes = fs::read(&git_midx_path).unwrap();
    let midx = MidxView::parse(&git_midx_bytes, ObjectFormat::Sha1).unwrap();

    let all_commits = rev_list_all(tmp.path());

    // Get HEAD (merge commit on main) as the tip - this is the most recent commit
    // that can reach all other commits via parent links
    let head_hex = git_output(tmp.path(), &["rev-parse", "HEAD"]);
    let tip_oid = oid_from_hex(&head_hex);

    let pack_dirs = collect_pack_dirs(&paths);
    let pack_paths = resolve_pack_paths_from_midx(&midx, &pack_dirs).unwrap();

    let commits = load_commits_from_tips(
        &[tip_oid],
        &midx,
        &pack_paths,
        ObjectFormat::Sha1,
        &CommitLoadLimits::default(),
        None,
    )
    .unwrap();

    let mem_cg = CommitGraphMem::build(commits, ObjectFormat::Sha1).unwrap();

    let mut scratch = ParentScratch::new();

    // Verify parent relationships match what git reports
    for commit_oid in &all_commits {
        let commit_hex = format!("{commit_oid}");
        let expected_parents = parent_oids(tmp.path(), &commit_hex);

        let pos = mem_cg.lookup(commit_oid).unwrap().unwrap();
        mem_cg.collect_parents(pos, 256, &mut scratch).unwrap();

        let actual_parent_oids: Vec<OidBytes> = scratch
            .as_slice()
            .iter()
            .map(|p| mem_cg.commit_oid(*p))
            .collect();

        // Sort for comparison since order may differ
        let expected_set: HashSet<_> = expected_parents.into_iter().collect();
        let actual_set: HashSet<_> = actual_parent_oids.into_iter().collect();

        assert_eq!(
            expected_set, actual_set,
            "parent OIDs should match for commit {commit_oid}"
        );
    }
}

// ============================================================================
// End-to-End Correctness Tests
// ============================================================================

struct TestResolver {
    refs: Vec<(Vec<u8>, OidBytes)>,
}

impl StartSetResolver for TestResolver {
    fn resolve(
        &self,
        _paths: &scanner_rs::git_scan::GitRepoPaths,
    ) -> Result<Vec<(Vec<u8>, OidBytes)>, RepoOpenError> {
        Ok(self.refs.clone())
    }
}

struct NoWatermarkStore;

impl RefWatermarkStore for NoWatermarkStore {
    fn load_watermarks(
        &self,
        _repo_id: u64,
        _policy_hash: [u8; 32],
        _start_set_id: [u8; 32],
        ref_names: &[&[u8]],
    ) -> Result<Vec<Option<OidBytes>>, RepoOpenError> {
        Ok(vec![None; ref_names.len()])
    }
}

#[test]
fn inmem_artifacts_produce_same_commit_plan_as_disk() {
    if !git_available() {
        eprintln!("git not available; skipping");
        return;
    }

    let tmp = create_repo_with_linear_history(5);

    let head = git_output(tmp.path(), &["rev-parse", "HEAD"]);
    let tip_oid = oid_from_hex(&head);

    let resolver = TestResolver {
        refs: vec![(b"refs/heads/main".to_vec(), tip_oid)],
    };
    let start_set_id = StartSetConfig::DefaultBranchOnly.id();

    // Open with disk artifacts
    let state = scanner_rs::git_scan::repo_open(
        tmp.path(),
        1,
        [0u8; 32],
        start_set_id,
        &resolver,
        &NoWatermarkStore,
        RepoOpenLimits::DEFAULT,
    )
    .unwrap();

    // Get planned commits using disk CommitGraphView
    let disk_cg = CommitGraphView::open_repo(&state).unwrap();
    let disk_plan: Vec<u32> = CommitPlanIter::new(&state, &disk_cg, CommitWalkLimits::DEFAULT)
        .unwrap()
        .map(|item| item.unwrap().pos.0)
        .collect();

    // Build in-memory commit graph
    let paths =
        GitRepoPaths::resolve::<RepoOpenError, _>(tmp.path(), &RepoOpenLimits::DEFAULT).unwrap();
    let pack_dir = paths.objects_dir.join("pack");
    let git_midx_path = pack_dir.join("multi-pack-index");
    let git_midx_bytes = fs::read(&git_midx_path).unwrap();
    let midx = MidxView::parse(&git_midx_bytes, ObjectFormat::Sha1).unwrap();

    let pack_dirs = collect_pack_dirs(&paths);
    let pack_paths = resolve_pack_paths_from_midx(&midx, &pack_dirs).unwrap();

    let commits = load_commits_from_tips(
        &[tip_oid],
        &midx,
        &pack_paths,
        ObjectFormat::Sha1,
        &CommitLoadLimits::default(),
        None,
    )
    .unwrap();

    let mem_cg = CommitGraphMem::build(commits, ObjectFormat::Sha1).unwrap();

    // Get planned commits using in-memory CommitGraphMem
    let mem_plan: Vec<u32> = CommitPlanIter::new(&state, &mem_cg, CommitWalkLimits::DEFAULT)
        .unwrap()
        .map(|item| item.unwrap().pos.0)
        .collect();

    // Both should produce the same number of commits
    assert_eq!(
        disk_plan.len(),
        mem_plan.len(),
        "disk and in-memory should produce same number of planned commits"
    );

    // The actual positions may differ (due to different ordering schemes),
    // but the commit OIDs should be the same set
    let disk_oids: HashSet<OidBytes> = disk_plan
        .iter()
        .map(|&pos| disk_cg.commit_oid(gix_commitgraph::Position(pos)).unwrap())
        .collect();

    let mem_oids: HashSet<OidBytes> = mem_plan
        .iter()
        .map(|&pos| mem_cg.commit_oid(gix_commitgraph::Position(pos)))
        .collect();

    assert_eq!(
        disk_oids, mem_oids,
        "disk and in-memory should produce same commit OIDs"
    );
}

#[test]
fn inmem_midx_produces_correct_offsets() {
    if !git_available() {
        eprintln!("git not available; skipping");
        return;
    }

    let tmp = create_repo_with_linear_history(3);

    // Get all objects from git
    let all_objects_output = git_output(tmp.path(), &["rev-list", "--all", "--objects"]);
    let all_oids: Vec<OidBytes> = all_objects_output
        .lines()
        .filter_map(|line| {
            let hex = line.split_whitespace().next()?;
            if hex.len() >= 40 {
                Some(oid_from_hex(hex))
            } else {
                None
            }
        })
        .collect();

    // Build our MIDX
    let paths =
        GitRepoPaths::resolve::<RepoOpenError, _>(tmp.path(), &RepoOpenLimits::DEFAULT).unwrap();
    let our_midx_bytes =
        build_midx_bytes(&paths, ObjectFormat::Sha1, &MidxBuildLimits::default()).unwrap();
    let our_midx = MidxView::parse(our_midx_bytes.as_slice(), ObjectFormat::Sha1).unwrap();

    // Read git MIDX
    let pack_dir = paths.objects_dir.join("pack");
    let git_midx_path = pack_dir.join("multi-pack-index");
    let git_midx_bytes = fs::read(&git_midx_path).unwrap();
    let git_midx = MidxView::parse(&git_midx_bytes, ObjectFormat::Sha1).unwrap();

    // Verify offsets match for all objects
    for oid in &all_oids {
        let our_idx = our_midx.find_oid(oid).unwrap().unwrap();
        let git_idx = git_midx.find_oid(oid).unwrap().unwrap();

        let (_our_pack, our_offset) = our_midx.offset_at(our_idx).unwrap();
        let (_git_pack, git_offset) = git_midx.offset_at(git_idx).unwrap();

        // Pack IDs may differ due to ordering, but offsets within the same pack should match
        // Since we use deterministic ordering, they should actually be the same
        assert_eq!(
            our_offset, git_offset,
            "offset for {oid} should match: our={our_offset}, git={git_offset}"
        );
    }
}

#[test]
fn commit_loader_loads_all_reachable_commits() {
    if !git_available() {
        eprintln!("git not available; skipping");
        return;
    }

    let tmp = create_repo_with_merge();

    // Get expected commits from git
    let expected_commits: HashSet<OidBytes> = rev_list_all(tmp.path()).into_iter().collect();

    // Load commits using our loader
    let paths =
        GitRepoPaths::resolve::<RepoOpenError, _>(tmp.path(), &RepoOpenLimits::DEFAULT).unwrap();
    let pack_dir = paths.objects_dir.join("pack");
    let git_midx_path = pack_dir.join("multi-pack-index");
    let git_midx_bytes = fs::read(&git_midx_path).unwrap();
    let midx = MidxView::parse(&git_midx_bytes, ObjectFormat::Sha1).unwrap();

    let pack_dirs = collect_pack_dirs(&paths);
    let pack_paths = resolve_pack_paths_from_midx(&midx, &pack_dirs).unwrap();

    let head = git_output(tmp.path(), &["rev-parse", "HEAD"]);
    let tip_oid = oid_from_hex(&head);

    let commits = load_commits_from_tips(
        &[tip_oid],
        &midx,
        &pack_paths,
        ObjectFormat::Sha1,
        &CommitLoadLimits::default(),
        None,
    )
    .unwrap();

    let loaded_oids: HashSet<OidBytes> = commits.iter().map(|c| c.oid).collect();

    assert_eq!(
        expected_commits, loaded_oids,
        "loaded commits should match git rev-list"
    );
}

#[test]
fn commit_loader_tree_oids_match_git() {
    if !git_available() {
        eprintln!("git not available; skipping");
        return;
    }

    let tmp = create_repo_with_linear_history(3);

    let paths =
        GitRepoPaths::resolve::<RepoOpenError, _>(tmp.path(), &RepoOpenLimits::DEFAULT).unwrap();
    let pack_dir = paths.objects_dir.join("pack");
    let git_midx_path = pack_dir.join("multi-pack-index");
    let git_midx_bytes = fs::read(&git_midx_path).unwrap();
    let midx = MidxView::parse(&git_midx_bytes, ObjectFormat::Sha1).unwrap();

    let pack_dirs = collect_pack_dirs(&paths);
    let pack_paths = resolve_pack_paths_from_midx(&midx, &pack_dirs).unwrap();

    let head = git_output(tmp.path(), &["rev-parse", "HEAD"]);
    let tip_oid = oid_from_hex(&head);

    let commits = load_commits_from_tips(
        &[tip_oid],
        &midx,
        &pack_paths,
        ObjectFormat::Sha1,
        &CommitLoadLimits::default(),
        None,
    )
    .unwrap();

    // Verify each commit's tree OID matches what git reports
    for commit in &commits {
        let commit_hex = format!("{}", commit.oid);
        let expected_tree = tree_oid_for_commit(tmp.path(), &commit_hex);

        assert_eq!(
            commit.tree_oid, expected_tree,
            "tree OID for {} should match git",
            commit.oid
        );
    }
}
